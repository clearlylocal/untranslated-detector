{"version":3,"sources":["check.tsx","App.tsx","serializeCol.tsx","index.tsx"],"names":["WORD_REGEX","STRIP_REGEX","EXCLUDE_REGEX","stored","JSON","parse","localStorage","getItem","sn","src","trg","cm","cmtmp","App","useForm","register","watch","handleSubmit","sheetName","srcColHeading","trgColHeading","commentsColHeading","commentTemplate","files","useMemo","useState","workbook","setWorkbook","useEffect","length","file","reader","FileReader","onload","e","data","Uint8Array","target","result","xlsx","read","type","readAsArrayBuffer","col","rows","Sheets","utils","sheet_to_json","parsed","Error","cloned","stringify","headers","header","some","name","includes","map","row","omitted","comment","strippedSrc","replace","strippedTrg","iter","split","entries","Symbol","iterator","dupes","n","next","done","value","idx","seg","toLowerCase","strs","nextSeg","join","push","last","pop","test","Set","filter","dupe","check","x","Boolean","console","error","window","onChange","setItem","defaultValue","ref","message","readOnly","p","cell","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.db750f03.chunk.js","sourcesContent":["// used with `test` - can't use `g` flag or becomes stateful\nconst WORD_REGEX = /([\\p{Letter}\\p{Mark}]+)/u\n\nconst STRIP_REGEX = /%\\d\\$\\w|<[^>]+>/g\nconst EXCLUDE_REGEX = /[%${}[\\]#:<>]/\nconst MIN_LENGTH_ANY_CASE = 2\nconst MIN_LENGTH_LOWER_CASE = 3\n\nexport function check(src: string, trg: string, comment: string) {\n\tconst strippedSrc = src.replace(STRIP_REGEX, '\\x1e') // record separator\n\tconst strippedTrg = trg.replace(STRIP_REGEX, '\\x1f') // unit separator\n\t// record separator and unit separator are arbitrary, but must\n\t// a) never be present in translatable content,\n\t// b) not match WORD_REGEX,\n\t// c) be different from each other to avoid false matches\n\n\tconst srcSepsAndWords = strippedSrc.split(WORD_REGEX)\n\n\tconst iter = srcSepsAndWords.entries()[Symbol.iterator]()\n\n\tlet dupes: string[] = []\n\n\twhile (true) {\n\t\tlet n = iter.next()\n\n\t\tif (n.done) break\n\n\t\tconst [idx, seg] = n.value\n\n\t\tif (idx % 2 === 0) {\n\t\t\t// is separator\n\t\t\tcontinue\n\t\t}\n\n\t\tif (strippedTrg.toLowerCase().includes(seg.toLowerCase())) {\n\t\t\tlet strs = [seg]\n\n\t\t\twhile (true) {\n\t\t\t\tn = iter.next()\n\n\t\t\t\tif (n.done) break\n\n\t\t\t\t// prettier-ignore\n\t\t\t\tconst [/* idx */, nextSeg] = n.value;\n\n\t\t\t\tif (\n\t\t\t\t\tstrippedTrg\n\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t.includes((strs.join('') + nextSeg).toLowerCase())\n\t\t\t\t) {\n\t\t\t\t\tstrs.push(nextSeg)\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet last = ''\n\n\t\t\twhile (last === '') {\n\t\t\t\tlast = strs.pop()\n\t\t\t}\n\n\t\t\tif (WORD_REGEX.test(last)) {\n\t\t\t\tstrs.push(last)\n\t\t\t}\n\n\t\t\tdupes.push(strs.join(''))\n\t\t}\n\t}\n\n\treturn [...new Set(dupes)].filter(dupe => {\n\t\tconst meetsMinLength =\n\t\t\tdupe.length >= MIN_LENGTH_LOWER_CASE ||\n\t\t\t(dupe !== dupe.toLowerCase() && dupe.length >= MIN_LENGTH_ANY_CASE)\n\n\t\treturn (\n\t\t\tmeetsMinLength &&\n\t\t\t!EXCLUDE_REGEX.test(dupe) &&\n\t\t\t!comment.includes(dupe)\n\t\t)\n\t})\n}\n","import { useEffect, useMemo, useState } from 'react'\nimport { useForm } from 'react-hook-form'\nimport './App.css'\nimport xlsx from 'xlsx'\nimport { check } from './check'\nimport { serializeCol } from './serializeCol'\n\nconst init = {\n\tsn: 'Sheet1',\n\tsrc: 'eng',\n\ttrg: 'bn-rBD',\n\tcm: 'Note',\n\tcmtmp: 'Same as English: {{words}}',\n}\n\nconst stored: typeof init =\n\tJSON.parse(localStorage.getItem('form') ?? 'null') ?? init\n\nexport const App = () => {\n\tconst { register, watch, handleSubmit } = useForm()\n\n\tconst changeHandler = (data: any) => {\n\t\tlocalStorage.setItem('form', JSON.stringify(data))\n\t}\n\n\tconst sheetName: string = watch('sn') ?? stored.sn\n\n\tconst srcColHeading: string = watch('src') ?? stored.src\n\tconst trgColHeading: string = watch('trg') ?? stored.trg\n\tconst commentsColHeading: string = watch('cm') ?? stored.cm\n\n\tconst commentTemplate: string = watch('cmtmp') ?? stored.cmtmp\n\n\tconst files: FileList = useMemo(\n\t\t() => watch('file') ?? ([] as any as FileList),\n\t\t[watch],\n\t)\n\n\tconst [workbook, setWorkbook] = useState<xlsx.WorkBook | null>(null)\n\n\tuseEffect(() => {\n\t\tif (!files.length) return\n\n\t\tconst file = files[0]\n\t\tconst reader = new FileReader()\n\t\treader.onload = e => {\n\t\t\tconst data = new Uint8Array(e.target.result as ArrayBuffer)\n\t\t\tconst workbook = xlsx.read(data, { type: 'array' })\n\n\t\t\tsetWorkbook(workbook)\n\t\t}\n\n\t\treader.readAsArrayBuffer(file)\n\t}, [files])\n\n\tconst rows = useMemo(() => {\n\t\tif (!workbook?.Sheets?.[sheetName]) {\n\t\t\treturn []\n\t\t}\n\n\t\tconst rows = xlsx.utils.sheet_to_json(workbook.Sheets[sheetName], {})\n\n\t\treturn rows\n\t}, [workbook, sheetName]) as Record<string, string>[]\n\n\tconst parsed = useMemo(() => {\n\t\tif (!workbook) {\n\t\t\treturn new Error('Upload a file')\n\t\t}\n\n\t\tconst cloned = JSON.parse(JSON.stringify(rows)) as typeof rows\n\n\t\ttry {\n\t\t\tconst headers = xlsx.utils.sheet_to_json(\n\t\t\t\tworkbook.Sheets[sheetName],\n\t\t\t\t{ header: 1 },\n\t\t\t)[0] as string[]\n\n\t\t\tif (!headers?.length) {\n\t\t\t\treturn new Error('Sheet not found or has no headers')\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t[srcColHeading, trgColHeading, commentsColHeading].some(\n\t\t\t\t\tname => !headers.includes(name),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn new Error('Not all headers found')\n\t\t\t}\n\n\t\t\treturn cloned.map(row => {\n\t\t\t\tconst omitted = check(\n\t\t\t\t\trow[srcColHeading] ?? '',\n\t\t\t\t\trow[trgColHeading] ?? '',\n\t\t\t\t\trow[commentsColHeading] ?? '',\n\t\t\t\t)\n\n\t\t\t\tif (omitted.length) {\n\t\t\t\t\trow[commentsColHeading] = [\n\t\t\t\t\t\trow[commentsColHeading],\n\t\t\t\t\t\tcommentTemplate.replace(\n\t\t\t\t\t\t\t'{{words}}',\n\t\t\t\t\t\t\tomitted.map(x => `“${x}”`).join(', '),\n\t\t\t\t\t\t),\n\t\t\t\t\t]\n\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t.join('\\n---\\n')\n\t\t\t\t}\n\n\t\t\t\treturn row\n\t\t\t})\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\n\t\t\treturn e as Error\n\t\t}\n\t}, [\n\t\tworkbook,\n\t\trows,\n\t\tsrcColHeading,\n\t\ttrgColHeading,\n\t\tcommentsColHeading,\n\t\tcommentTemplate,\n\t\tsheetName,\n\t])\n\n\t;(window as any).parsed = parsed\n\n\treturn (\n\t\t<form onChange={handleSubmit(changeHandler)}>\n\t\t\t<label>\n\t\t\t\tSheet name\n\t\t\t\t<input\n\t\t\t\t\tname='sn'\n\t\t\t\t\tdefaultValue={stored.sn}\n\t\t\t\t\tref={register}\n\t\t\t\t></input>\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<label>\n\t\t\t\tSource col heading\n\t\t\t\t<input\n\t\t\t\t\tname='src'\n\t\t\t\t\tdefaultValue={stored.src}\n\t\t\t\t\tref={register}\n\t\t\t\t></input>\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<label>\n\t\t\t\tTarget col heading\n\t\t\t\t<input\n\t\t\t\t\tname='trg'\n\t\t\t\t\tdefaultValue={stored.trg}\n\t\t\t\t\tref={register}\n\t\t\t\t></input>\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<label>\n\t\t\t\tComments col heading\n\t\t\t\t<input\n\t\t\t\t\tname='cm'\n\t\t\t\t\tdefaultValue={stored.cm}\n\t\t\t\t\tref={register}\n\t\t\t\t></input>\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<label>\n\t\t\t\tComments template\n\t\t\t\t<input\n\t\t\t\t\tname='cmtmp'\n\t\t\t\t\tdefaultValue={stored.cmtmp}\n\t\t\t\t\tref={register}\n\t\t\t\t/>\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<label>\n\t\t\t\tUpload file (XLSX)\n\t\t\t\t<input type='file' name='file' ref={register} />\n\t\t\t</label>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<hr />\n\t\t\t<br />\n\t\t\t{parsed instanceof Error ? (\n\t\t\t\t<strong>{parsed.message}</strong>\n\t\t\t) : (\n\t\t\t\t<textarea\n\t\t\t\t\treadOnly\n\t\t\t\t\tvalue={serializeCol([\n\t\t\t\t\t\tcommentsColHeading,\n\t\t\t\t\t\t...parsed.map(p => p[commentsColHeading] ?? ''),\n\t\t\t\t\t])}\n\t\t\t\t/>\n\t\t\t)}\n\t\t</form>\n\t)\n}\n","export function serializeCol(col: string[]) {\n\treturn col\n\t\t.map(cell =>\n\t\t\t/[\\t\\n\"]/.test(cell) ? `\"${cell.split('\"').join('\"\"')}\"` : cell,\n\t\t)\n\t\t.join('\\n')\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport { App } from './App'\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root'),\n)\n"],"sourceRoot":""}